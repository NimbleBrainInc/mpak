"""Package name analysis utilities for slopsquatting detection.

This module provides utilities for detecting package names that exploit
LLM hallucination patterns (slopsquatting). It is NOT a compliance control
but a utility that registries can use for RG-02 (Name Pattern Review).

Note: Per MTF v0.1, slopsquatting detection is a registry-enforced control
(RG-02), not a scanner control. This utility can be called by registries
or exposed as an optional CLI check.
"""

import re
from dataclasses import dataclass

# Known hallucinated package names corpus
# These are package names commonly generated by LLMs but never legitimately published.
# Sources: Academic research, community reports, automated LLM probing
HALLUCINATION_CORPUS = {
    # Python hallucinations
    "flask-auth-helper",
    "flask-auth-utils",
    "flask-login-helper",
    "flask-secure",
    "flask-session-utils",
    "django-utils-helper",
    "django-auth-helper",
    "django-security-utils",
    "fastapi-middleware-auth",
    "fastapi-auth-helper",
    "fastapi-session",
    "requests-helper",
    "requests-utils",
    "http-client-utils",
    "api-client-wrapper",
    "json-parser-utils",
    "data-processing-utils",
    "ml-helper",
    "pytorch-utils",
    "tensorflow-helper",
    "numpy-helper",
    "pandas-helper",
    "scikit-helper",
    # Node.js hallucinations
    "react-state-utils",
    "react-form-helper",
    "react-auth-utils",
    "react-hooks-helper",
    "next-auth-helper",
    "express-auth-utils",
    "express-middleware-helper",
    "node-utils-helper",
    "api-wrapper-utils",
    # MCP-specific hallucinations
    "mcp-server-helper",
    "mcp-server-utils",
    "mcp-client-helper",
    "mcp-auth-utils",
    "mcp-tool-helper",
    "mcp-server-framework",
    "mcp-bundle-utils",
    "fastmcp-utils",
    "fastmcp-helper",
}

# Version-like suffix patterns that LLMs tend to hallucinate
VERSION_SUFFIX_PATTERNS = [
    r"^(.+?)(2|3|next|new|modern|advanced|pro)$",  # requests2, numpy-next
    r"^(.+?)-v\d+$",  # package-v2
]

# Compound word patterns commonly hallucinated
# Format: (prefix, suffix) pairs that create suspicious compound names
SUSPICIOUS_COMPOUND_PATTERNS = [
    # Generic helper/utils suffixes on framework names
    (r"^(flask|django|fastapi|express|react|vue|angular)", r"(helper|utils|tools)$"),
    # Auth/security compounds
    (r"^(api|http|web|server)", r"(auth|security|login)(helper|utils)?$"),
    # MCP compounds
    (r"^mcp", r"(helper|utils|wrapper|tools|framework)$"),
]

# Minimum Levenshtein distance to trigger similarity check
MIN_SIMILARITY_DISTANCE = 2


def levenshtein_distance(s1: str, s2: str) -> int:
    """Calculate Levenshtein distance between two strings."""
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)

    if len(s2) == 0:
        return len(s1)

    previous_row = list(range(len(s2) + 1))
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row

    return previous_row[-1]


def normalize_package_name(name: str) -> str:
    """Normalize package name for comparison."""
    # Remove scope if present (@org/package -> package)
    if name.startswith("@") and "/" in name:
        name = name.split("/", 1)[1]
    # Lowercase and normalize separators
    return name.lower().replace("_", "-")


def check_version_suffix(name: str) -> tuple[bool, str | None]:
    """Check if name has suspicious version-like suffix."""
    for pattern in VERSION_SUFFIX_PATTERNS:
        match = re.match(pattern, name)
        if match:
            base_name = match.group(1)
            return True, base_name
    return False, None


def check_compound_pattern(name: str) -> bool:
    """Check if name matches suspicious compound patterns."""
    for prefix_pattern, suffix_pattern in SUSPICIOUS_COMPOUND_PATTERNS:
        if re.search(prefix_pattern, name) and re.search(suffix_pattern, name):
            return True
    return False


def check_similarity_to_corpus(name: str, threshold: int = MIN_SIMILARITY_DISTANCE) -> list[str]:
    """Find corpus entries similar to the given name."""
    similar = []
    for hallucinated in HALLUCINATION_CORPUS:
        distance = levenshtein_distance(name, hallucinated)
        if distance <= threshold and distance > 0:  # Similar but not exact
            similar.append(hallucinated)
    return similar


@dataclass
class NameAnalysisResult:
    """Result of analyzing a package name for slopsquatting risk."""

    package_name: str
    normalized_name: str
    risk_score: int  # 0-100
    is_exact_match: bool
    similar_names: list[str]
    has_version_suffix: bool
    version_suffix_base: str | None
    has_compound_pattern: bool
    patterns_matched: list[str]

    @property
    def is_high_risk(self) -> bool:
        """Return True if this name is high risk (should block)."""
        return self.is_exact_match or self.risk_score >= 50

    @property
    def is_medium_risk(self) -> bool:
        """Return True if this name is medium risk (should warn)."""
        return not self.is_high_risk and self.risk_score >= 20


def analyze_package_name(package_name: str) -> NameAnalysisResult:
    """Analyze a package name for slopsquatting risk.

    This is the main entry point for package name analysis. It checks:
    1. Exact match against known hallucination corpus
    2. Similarity to hallucinated names (Levenshtein distance)
    3. Version-like suffix patterns
    4. Suspicious compound word patterns

    Args:
        package_name: The package name to analyze

    Returns:
        NameAnalysisResult with risk assessment
    """
    normalized_name = normalize_package_name(package_name)
    score = 0
    patterns_matched: list[str] = []

    # Check 1: Exact match against hallucination corpus (CRITICAL)
    is_exact_match = normalized_name in HALLUCINATION_CORPUS
    if is_exact_match:
        score = 100
        patterns_matched.append("exact_match")

    # Check 2: Similarity to hallucinated names
    similar_names = check_similarity_to_corpus(normalized_name)
    if similar_names:
        similarity_score = 50 if len(similar_names) >= 2 else 30
        score = max(score, similarity_score)
        patterns_matched.append("similarity")

    # Check 3: Version-like suffix pattern
    has_version_suffix, version_suffix_base = check_version_suffix(normalized_name)
    if has_version_suffix:
        score = max(score, 20)
        patterns_matched.append("version_suffix")

    # Check 4: Suspicious compound patterns
    has_compound_pattern = check_compound_pattern(normalized_name)
    if has_compound_pattern:
        score = max(score, 20)
        patterns_matched.append("compound_pattern")

    return NameAnalysisResult(
        package_name=package_name,
        normalized_name=normalized_name,
        risk_score=score,
        is_exact_match=is_exact_match,
        similar_names=similar_names,
        has_version_suffix=has_version_suffix,
        version_suffix_base=version_suffix_base,
        has_compound_pattern=has_compound_pattern,
        patterns_matched=patterns_matched,
    )
